<pre>
  NEP: <to be assigned>
  Title: Unified dApp API for wallet providers
  Author: Nick Fujita <nickfujita@gmail.com>, Matus Zamborsky <zamborsky@gmail.com>
  Type: Standard
  Status: Draft
  Created: 2018-08-28
</pre>

==Abstract==

This NEP describes a common API interface for dApps to communicate with external wallet providers. The use of a trusted 3rd party wallet providers will help users feel more secure when using dApps, and the unified interface will help dApp creators to have a more uniform developer experience when making their dApps compatible with various providers.


==Motivation==

===End Users===

As dApps come into the ecosystem, there will be more concerns about the safety of user assets. If dApps all required users to input their private keys in order to use them, it just takes one malicious dApp to steal all their funds. By using a trusted wallet provider which interfaces with the various dApps in the ecosystem on their behalf, users can reduce the exposure of their private keys. This will even allow users to transact with their hardware wallets via the wallet provider,  never having to reveal their private keys even to the wallet itself.

===dApp Developers===

One of the initial hurtles for any developer when starting to develop a dApp is to create a wallet module that will allow the user and application to interface with the NEO blockchain. While there are many quality SDKs out there such as neon-js for facilitating the communication of these requests, there are often many hurtles to successfully constructing the right combination of methods, along with input and output parsing. The issue only gets amplified when trying to integrate with hardware wallet providers such as a Ledger device.

While there may be several options for 3rd party wallet providers that will help them to facilitate these transactions, the is currently no common consensus on the consistency of their interfaces. With a lack of consistency in interfaces to use these wallet provider services, dApp developers will be forced to make a decision to have their platform supported by a single provider, or to double or even triple their development efforts to accommodate all the different wallet provider interfaces. This will lead to a fragmentation in the dApps ecosystem.

===Wallet providers===

Each wallet provider, when deciding on supporting dApps to utilize their services as an authentication mechanism will be faced with a decision on how to implement an API to communicate with the dApps. Wallet providers can choose to create their own API from scratch, create their own version of existing projects, or aim to directly duplication an existing API. In the case that the provider decides to make their own API interface from scratch, and try to promote dApps to use it, time and effort will inevitably be wasted by both the provider and competing providers on getting dApp developers on board with using their custom communication interface. If we have a unified interface for such transactions, providers can spend more time on making their individual services better for their users.

The current list of wallet providers that can benefit from the use of this protocol are currently:
* NEL Chrome extension
* nOS dApps browser
* NeoLink Chrome extension
* NEX Chrome extension
* O3 dApps browser

Each wallet provider has their own value proposition to it's users beyond the interface from this protocol itself, so it seems that formalizing it would be a net positive for all.

Additionally, since there are a significant amount of overlap in the protocols between NEO and Ontology for sending assets, and interacting with contract on NeoVM, this proposal is a joint effort with [https://github.com/ontio/OEPs/pull/8 OEP6]. Since there are differences in the two platforms, the result of these proposals will not be identical, nor should they be, but getting as much overlap as possible will help to simplify cross-chain interactions for both platforms.


==Specification==

'''Provider Request Handling'''

Implementation details of per dApp domain handling will be left to the discretion of the wallet provider. Providers can choose to allow users to trust certain dApps to automatically execute transaction on their behalf, or a certain subset of transaction types. Below are basic guidelines for general handling of requests from dApps via the protocol interface.

===Read Methods===

====getProvider====
Returns information about the  dAPI provider, including who this provider is, the version of their dAPI, and the NEP that the interface is compatible with.


'''Method Interface'''

<pre>
function getProvider(): Promise<Provider>
</pre>


'''Input arguments'''

None


'''Success return value'''

object - Provider information defined by the interface below:
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
  extra: object; //this object can contain any attributes specific to the dapi provider, such as an app theme.
}
</pre>

The compatibility field will return a list of strings that corresponds to NEPs that the dAPI conforms to. For example:
<pre>
compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
]
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getProvider()
.then((provider: Provider) => {
  const {
    name,
    website,
    version,
    compatibility,
    extra,
  } = provider;

  console.log('Provider name: ' + name);
  console.log('Provider website: ' + website);
  console.log('Provider dAPI version: ' + version);
  console.log('Provider dAPI compatibility: ' + JSON.stringify(compatibility));
  console.log('Extra provider specific atributes: ' + JSON.stringify(compatibility));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
* The name of the provider wallet
* The provider website
* The provider specific version of the wallet
* A list of NEP for which the specific provider protocol is compatible with

Example
<pre>
{
  name: 'Awesome Wallet',
  website: 'https://www.awesome.com',
  version: 'v0.0.1',
  compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
  ],
  extra: {
    theme: 'Dark Mode'
  }
}
</pre>


====getNetworks====
Returns the networks the wallet provider has available to connect to, along with the default network the wallet is currently set to.


'''Method Interface'''

<pre>
function getNetworks(): Promise<Networks>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Networks {
  networks: string[]; // Array of network names the wallet provider has available for the dapp developer to connect to.
  defaultNetwork: string; // Network the wallet is currently set to.
}
</pre>

'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getNetworks()
.then(response => {
  const {
    networks,
    defaultNetwork,
  } = response.networks;

  console.log('Networks: ' + networks);
  // eg. ["MainNet", "TestNet", "PrivateNet"]

  console.log('Default network: ' + defaultNetwork);
  // eg. "MainNet"
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The list of NEO networks that the wallet is able to connect to. The return values will be used by the dapp developer to communicate to which network they would like their request to be directed to. The wallet provider will be responsible for the logistics of which node to submit any request to for each network alias provided.
- The wallet provider is to also return the default network that the wallet UI is currently set to by user.

Example
<pre>
{
  networks: ["MainNet", "TestNet", "PrivateNet"],
  defaultNetwork: "TestNet",
}
</pre>


====getAccount====
Return the Account that is currently connected to the dApp.


'''Method Interface'''

<pre>
function getAccount(): Promise<{ address: string, label: string }>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Account {
  address: string; // Address of the connected account
  label?: string; // A label the users has set to identify their wallet
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getAccount()
.then((account: Account) => {
  const {
    address,
    label
  } = account;

  console.log('Provider address: ' + address);
  console.log('Provider account label (Optional): ' + label);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The address and label of account currently selected by the user in the wallet interface

Example
<pre>
{
  address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  label: 'My Spending Wallet'
}
</pre>


====getPublicKey====
Return the public key of the Account that is currently connected to the dApp.


'''Method Interface'''

<pre>
function getPublicKey(): Promise<{ address: string, publicKey: string }>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Account {
  address: string; // Address of the connected account
  publicKey: string; // Public key of the connected account
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getPublicKey()
.then((publicKeyData: PublicKeyData) => {
  const {
    address,
    publicKey,
  } = publicKeyData;

  console.log('Account address: ' + address);
  console.log('Account public key: ' + publicKey);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The address and public key of account currently selected by the user in the wallet interface

Example
<pre>
{
  address: 'ATUaTd3LA4kZiyB6it9fdb5oJpZYMBF4DX',
  publicKey: '03fa41b6ff75ebeff8464556629cfceae7402f5d815626a7a6542f786974b942e0'
}
</pre>


====getBalance====
Return balance of a specific asset for the given account.

If the asset is omitted from a request to MainNet, all asset and token balances will be returned.


'''Method Interface'''

<pre>
function getBalance(args: GetBalanceArgs): Promise<BalanceResults>
</pre>


'''Input arguments'''

<pre>
interface GetBalanceArgs {
  params: BalanceRequest|BalanceRequest[];
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
}

interface BalanceRequest {
  address: string; // Address to check balance(s)
  assets?: string|string[]; // Asset ID or script hash to check balance.
  fetchUTXO?: boolean; // Fetches to UTXO data for NEO and/or GAS if attribute is 'true'
}
</pre>


'''Success return value'''

<pre>
interface BalanceResults {
  [address: string]: Balance[];
}

interface Balance {
  assetID: string;
  symbol: string;
  amount: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_DENIED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getBalance({
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['c36aee199dbba6c3f439983657558cfb67629599']
  },
})
.then((results: BalanceResults) => {
  Object.keys(results).forEach(address => {
    const balances = results[address];
    balances.forEach(balance => {
      const { assetID, symbol, amount } = balance

      console.log('Address: ' + address);
      console.log('Asset ID: ' + assetID);
      console.log('Asset symbol: ' + symbol);
      console.log('Amount: ' + amount);
    });
  });
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>

Single asset balance request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['c36aee199dbba6c3f439983657558cfb67629599']
  },
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    }
  ],
}
</pre>

Single account balances request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  },
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'assetID': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'assetID': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ]
}

Multiple account balances request sample
<pre>
// input
{
  params: [
    {
      address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    },
    {
      address: 'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ',
      asset: '1578103c13e39df15d0d29826d957e85d770d8c9',
    },
  ]
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'assetID': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'assetID': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'assetID': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'assetID': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ],
  'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ': [
    {
      'assetID': '1578103c13e39df15d0d29826d957e85d770d8c9',
      'symbol': 'PHX',
      'amount': '11000',
    }
  ]
}
</pre>

'''Provider Request Handling'''

Upon receiving this request, fetch the latest balance(s) for each given account, for the specific asset if applicable.
Typechecking will be required on the input argument, as it can be eather a single BalanceRequest object, or an array of BalanceRequest objects. In the case where a specific asset is not provided to check the balance for, the wallet provider will fetch balances for all assets and tokens for that account.


====getStorage====
Reads the raw value in smart contract storage.


'''Method Interface'''

<pre>
function getStorage({ scriptHash: string, key: string, network?: string }): Promise<StorageResponse>
</pre>


'''Input arguments'''

<pre>
interface GetStorageArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on
  key: string; // key of the storage value to retrieve from the contract
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
}
</pre>


'''Success return value'''

<pre>
interface StorageResponse {
  result: string; // The raw value that's stored in the contract
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getStorage({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  key: 'game.status'
})
.then(res => {
  const value = res.result;
  console.log('Storage value: ' + value);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  result: 'hello world'
}
</pre>


====invokeRead====
Execute a contract invocation in read-only mode.


'''Method Interface'''

<pre>
function invokeRead({
  scriptHash: string,
  operation: string,
  args: Argument[]
  network?: string,
 }): Promise<result: Object>
</pre>

'''Input arguments'''

<pre>
interface InvokeReadArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';
</pre>


'''Success return value'''

result: Object - Response from RPC node


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invokeRead({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'calculatorAdd',
  arguments: [
    {
      type: 'integer',
      value: 2
    },
    {
      type: 'integer',
      value: 10
    }
  ]
})
.then((result: Object) => {
  console.log('Read invocation result: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  script: '8h89fh398f42f.....89hf2894hf9834',
  state: 'HALT, BREAK',
  gas_consumed: '0.13',
  stack: [
    {
      type: 'Integer',
      value: '1337'
    }
  ]
}
</pre>


====getBlock====
Get information about a specific block.


'''Method Interface'''

<pre>
function getBlock({
  blockHeight: integer,
  network?: string
}): Promise<{result: BlockDetails}>
</pre>


'''Input arguments'''

<pre>
interface GetBlockInputArgs {
  blockHeight: integer;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
interface BlockDetails {
  hash: string; // Block hash
  size: number; // Block size (bytes)
  version: number; // The version number of the block execution
  previousblockhash: string; // Previous block Hash
  merkleroot: string; // Merkel root
  time: number; // Block generation timestamp
  index: number; // Block index (height)
  nonce: string; // Block pseudo-random number
  nextconsensus: string; // Next master biller
  script: ScriptDetails; // Block call signature authentication information
  tx: BlockTransactionDetails[]; // Block containing trading group
  confirmations: number; // Confirmation number (number of blocks after this block)
  nextblockhash: string; // Next block hash
}

interface BlockTransactionDetails {
  txid: string;
  size: number;
  type: string;
  version: number;
  attributes: any[];
  vin: any[];
  vout: any[];
  sys_fee: string;
  net_fee: string;
  scripts: any[];
  nonce: number;
}

interface ScriptDetails {
  invocation: string;
  verification: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getBlock({
  blockHeight: 2619690,
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Block information: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "hash": "0xc1668a114ee680597196ed402a0e0507fd8348e6090a54250d7accfadbd74b6e",
  "size": 686,
  "version": 0,
  "previousblockhash": "0xbae289c94e17ae90022673186fd6e1e48b7dd7afb89319bff0e2832db06d16b3",
  "merkleroot": "0x07d70f7337d3869a7daa538425d78a47212fb8c6130d66d84ac48526853a4e51",
  "time": 1557376153,
  "index": 2619690,
  "nonce": "8efd62ebb85ee68b",
  "nextconsensus": "AWZo4qAxhT8fwKL93QATSjCYCgHmCY1XLB",
  "script": {
    "invocation": "402a1dab9e5593d1d7d2a22a36772d4541b8053d33f8b8474b7d5a20066c1bd821e051fc252ed16146930d55ecb17fbb74972fba4c4b27af81a707999ca1313dd2401520eba2dd3b54a74a798cbb716c484ba6f6f21218f099e3d622a0fbd15989f38f9b0b344daf9b89175055d3a92f49df65118e8598735d651bedd4f1811baeb140e6491c03f3057f404d2fe7db50e40e82ade405a9dc7fccd81f4ba0b499a4a29f8570d631b8d40c5995b17d9391fe9ff8c73f28a4e1eb922b7a1ce9d1a5dc0448402cfcdede54828875d45402120aa2d8f78c7bd40df5e5d3b1873fd7e4d03672ebd0904f90c90fa519c623968f55550ae55374de66dc0db9c9d865c593bb95be5640214db0cd3cea6f4ad866df4129d482b89583805d1bdb08ce8399881e70351778a3e4a4093cf69aa7b99b83347fbfd38d85ff45d6a78ca2ab8cacffbfbc8c2d16",
    "verification": "5521030ef96257401b803da5dd201233e2be828795672b775dd674d69df83f7aec1e36210327da12b5c40200e9f65569476bbff2218da4f32548ff43b6387ec1416a231ee821025bdf3f181f53e9696227843950deb72dcd374ded17c057159513c3d0abe20b64210266b588e350ab63b850e55dbfed0feeda44410a30966341b371014b803a15af0721026ce35b29147ad09e4afe4ec4a7319095f08198fa8babbe3c56e970b143528d222103c089d7122b840a4935234e82e26ae5efd0c2acb627239dc9f207311337b6f2c12103fd95a9cb3098e6447d0de9f76cc97fd5e36830f9c7044457c15a0e81316bf28f57ae"
  },
  "tx": [
    {
      "txid": "0x07d70f7337d3869a7daa538425d78a47212fb8c6130d66d84ac48526853a4e51",
      "size": 10,
      "type": "MinerTransaction",
      "version": 0,
      "attributes": [],
      "vin": [],
      "vout": [],
      "sys_fee": "0",
      "net_fee": "0",
      "scripts": [],
      "nonce": 3093227147
    }
  ],
  "confirmations": 70,
  "nextblockhash": "0x2c9d6a107b21e83e09dd1b89df344a726895147d410120c46996290692ba29aa"
}
</pre>


====getTransaction====
Get information about a specific transaction.


'''Method Interface'''

<pre>
function getTransaction({
  txid: string,
  network?: string
}): Promise<{result: TransactionDetails}>
</pre>


'''Input arguments'''

<pre>
interface TransactionInputArgs {
  txid: string;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
export interface TransactionDetails {
  txid: string;
  size: number;
  type: string;
  version: number;
  attributes: TransactionAttribute[];
  vin: any[];
  vout: any[];
  sys_fee: string;
  net_fee: string;
  scripts: TransactionScript[];
  script: string;
  gas: string;
  blockhash: string;
  confirmations: number;
  blocktime: number;
}

interface TransactionAttribute {
  usage: string;
  data: string;
}

interface TransactionScript {
  invocation: string;
  verification: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getTransaction({
  txid: '7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2',
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Transaction details: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "txid": "0x7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2",
  "size": 556,
  "type": "InvocationTransaction",
  "version": 1,
  "attributes": [
    {
      "usage": "Script",
      "data": "296ac124021a71c449a9bad320c16429b08ad6ee"
    },
    {
      "usage": "Remark",
      "data": "cbb549adec34d741"
    }
  ],
  "vin": [],
  "vout": [],
  "sys_fee": "0",
  "net_fee": "0",
  "scripts": [
    {
      "invocation": "4072b83e8aca62c27dc36b032b895e757db00620384e26f43cd0ecc9904bff1e652dd94a03226d6dcb0b6f91104cb40be6455aa0fc3b474a8a8e5fa43ff4b10b8d40af726dc0976f15cd8a134634074c5613ab1e59979fec37b611392975c92afa11038fd9d96ddfb306df12ae200dc3c15fa17cb9530389e28f090fd8c9721c3307",
      "verification": "53c56b6c766b00527ac46c766b51527ac4616c766b00c36121022949376faacb0c6783da8ab63548926cb3a2e8d786063a449833f927fa8853f0ac642f006c766b51c361210292a25f5f0772d73d3fb50d42bb3cb443505b15e106789d19efa4d09c5ddca756ac635f006c766b00c361210292a25f5f0772d73d3fb50d42bb3cb443505b15e106789d19efa4d09c5ddca756ac642f006c766b51c36121022949376faacb0c6783da8ab63548926cb3a2e8d786063a449833f927fa8853f0ac62040000620400516c766b52527ac46203006c766b52c3616c7566"
    }
  ],
  "script": "0400e1f505147869ef9732cdf6f6d54adaa5cae3b55a9396bceb14296ac124021a71c449a9bad320c16429b08ad6ee53c1087472616e7366657267f1dfcf0051ec48ec95c8d0569e0b95075d099d84f10400e1f50514b1fdddf658ce5ff9f83e66ede2f333ecfcc0463e14296ac124021a71c449a9bad320c16429b08ad6ee53c1087472616e7366657267f1dfcf0051ec48ec95c8d0569e0b95075d099d84f1",
  "gas": "0",
  "blockhash": "0x4ea57fe267a392933d2b03fa733fbf1fa12c13f7e8ae2051e45465800e1a7cdb",
  "confirmations": 9,
  "blocktime": 1557377749
}
</pre>


====getApplicationLog====
Get the application log for a given transaction.


'''Method Interface'''

<pre>
function getApplicationLog({
  txid: string,
  network?: string
}): Promise<{result: ApplicationLog}>
</pre>


'''Input arguments'''

<pre>
interface TransactionInputArgs {
  txid: string;
  network?: string;
}
</pre>


'''Success return value'''

<pre>
export interface ApplicationLog {
  txid: string;
  blockindex: number;
  executions: ExecutionDetails[];
}

interface ExecutionDetails {
  trigger: string;
  contract: string;
  vmstate: string;
  gas_consumed: string;
  stack: Argument[];
  notifications: Notification[];
}

interface Notification {
  contract: string;
  state: {
    type: 'Array';
    value: Argument[];
  };
}

interface Argument {
  type: string;
  value: string;
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
getApplicationLog({
  txid: '7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2',
  network: 'TestNet'
})
.then((result: Object) => {
  console.log('Application log of transaction execution: ' + JSON.stringigy(result));
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Broadcast the RPC request
* Return the RPC response results


Example
<pre>
{
  "txid": "0x7e049fd7c253dabf38e4156df30c78b30d49f307196aa89b99a47d2330789bf2",
  "executions": [
    {
      "trigger": "Application",
      "contract": "0x72985e7f2cea98b89af54d8607bc6400814c4b45",
      "vmstate": "HALT",
      "gas_consumed": "5.292",
      "stack": [],
      "notifications": [
        {
          "contract": "0x849d095d07950b9e56d0c895ec48ec5100cfdff1",
          "state": {
            "type": "Array",
            "value": [
              {
                "type": "ByteArray",
                "value": "7472616e73666572"
              },
              {
                "type": "ByteArray",
                "value": "296ac124021a71c449a9bad320c16429b08ad6ee"
              },
              {
                "type": "ByteArray",
                "value": "7869ef9732cdf6f6d54adaa5cae3b55a9396bceb"
              },
              {
                "type": "ByteArray",
                "value": "00e1f505"
              }
            ]
          }
        },
        {
          "contract": "0x849d095d07950b9e56d0c895ec48ec5100cfdff1",
          "state": {
            "type": "Array",
            "value": [
              {
                "type": "ByteArray",
                "value": "7472616e73666572"
              },
              {
                "type": "ByteArray",
                "value": "296ac124021a71c449a9bad320c16429b08ad6ee"
              },
              {
                "type": "ByteArray",
                "value": "b1fdddf658ce5ff9f83e66ede2f333ecfcc0463e"
              },
              {
                "type": "ByteArray",
                "value": "00e1f505"
              }
            ]
          }
        }
      ]
    }
  ]
}
</pre>


===Write Methods===
====send====
Invoke a transfer of a specified amount of a given asset from the connected account to another account.


'''Method Interface'''

<pre>
function send({
  fromAddress: string,
  toAddress: string,
  asset: string,
  amount: string,
  remark?: string,
  fee?: string,
  network?: string,
  broadcastOverride?: boolean,
}): Promise<SendOutput>
</pre>


'''Input arguments'''

<pre>
interface SendArgs {
  fromAddress: string; // Address of the connected account to send the assets from
  toAddress: string; // Address of the receiver of the assets to be sent
  asset: string; // Asset script hash to be sent
  amount: string; // The parsed amount of the asset to be sent
  remark?: string; // (Optional) Description of the transaction to be made
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string; //  Network to submit this request to. If omitted, will default to network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider
}
</pre>


'''Success return value'''

<pre>
interface SendOutput {
  txid: string; // The transaction ID of the send invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if transaction is broadcast by wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`|`INSUFFICIENT_FUNDS`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
send({
  fromAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  toAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  asset: '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
  amount: '0.0001',
  remark: 'Hash puppy clothing purchase. Invoice#abc123',
  fee: '0.0001'
})
.then(({txid, nodeUrl}: SendOutput) => {
  console.log('Send transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case SEND_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case MALFORMED_INPUT:
      console.log('The receiver address provided is not valid.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
    case INSUFFICIENT_FUNDS:
      console.log('The user has insufficient funds to execute this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate the inputs
** From address matches connected account
** To address is valid
** Validate asset exists
** Amount is valid value, and account has enough balance
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}
</pre>


====invoke====
Execute a contract invocation.


'''Method Interface'''

<pre>
function invoke({
  scriptHash: string,
  operation: string,
  args: Argument[],
  attachedAssets?: AttachedAssets,
  fee?: string,
  assetIntentOverrides?: AssetIntentOverrides,
  triggerContractVerification?: boolean,
  network?: string,
  broadcastOverride?: boolean,
  txHashAttributes?: TxHashAttribute[],
}): Promise<InvokeOutput>
</pre>


'''Input arguments'''

<pre>
interface InvokeArgs {
  scriptHash: string; // script hash of the smart contract to invoke
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
  attachedAssets?: AttachedAssets;
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider

  assetIntentOverrides?: AssetIntentOverrides;
  // A hard override of all transaction utxo inputs and outputs.
  // IMPORTANT: If provided, fee and attachedAssets will be ignored.

  triggerContractVerification?: boolean; // Adds the instruction to invoke the contract verification trigger

  txHashAttributes?: TxHashAttribute[]; // Adds transaction attributes for the "Hash<x>" usage block
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

interface TxHashAttribute extends Argument {
  txAttrUsage: 'Hash1'|'Hash2'|'Hash3'|'Hash4'|'Hash5'|'Hash6'|'Hash7'|'Hash8'|'Hash9'|'Hash10'|'Hash11'|'Hash12'|'Hash13'|'Hash14'|'Hash15';
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';

interface AttachedAssets {
  [asset: 'NEO'|'GAS']: string;
}
// KEY: Asset symbol (only NEO or GAS)
// VALUE: Parsed amount to attach

interface AssetIntentOverrides {
  inputs: AssetInput[];
  outputs: AssetOutput[];
}

interface AssetInput {
  txid: string;
  index: number;
}

interface AssetOutput {
  asset: string;
  address: number;
  value: string;
}

</pre>


'''Success return value'''

interface InvokeOutput {
  txid: string; // The transaction ID of the invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if transaction is broadcast by wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invoke({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'storeData',
  arguments: [
    {
      type: 'string',
      value: 'hello'
    }
  ],
  attachedAssets: {
    NEO: '100',
    GAS: '0.0001',
  },
  fee: '0.001'
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Invoke transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


====invokeMulti====
Execute a multiple contract invocations in a single transaction.


'''Method Interface'''

<pre>
function invoke({
  invokeArgs: InvokeArguments[],
  fee?: string,
  assetIntentOverrides?: AssetIntentOverrides,
  network?: string,
  broadcastOverride?: boolean,
  txHashAttributes?: TxHashAttribute[],
}): Promise<InvokeOutput>
</pre>


'''Input arguments'''

<pre>
interface InvokeArgs {
  invokeArgs: InvokeArguments[]; List of contract invoke inputs

  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider

  assetIntentOverrides?: AssetIntentOverrides;
  // A hard override of all transaction utxo inputs and outputs.
  // IMPORTANT: If provided, fee and attachedAssets will be ignored.

  txHashAttributes?: TxHashAttribute[]; // Adds transaction attributes for the "Hash<x>" usage block
}

interface InvokeArguments {
  scriptHash: string; // script hash of the smart contract to invoke
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  attachedAssets?: AttachedAssets;
  triggerContractVerification?: boolean; // Adds the instruction to invoke the contract verification trigger
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

interface TxHashAttribute extends Argument {
  txAttrUsage: 'Hash1'|'Hash2'|'Hash3'|'Hash4'|'Hash5'|'Hash6'|'Hash7'|'Hash8'|'Hash9'|'Hash10'|'Hash11'|'Hash12'|'Hash13'|'Hash14'|'Hash15';
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Hash256'|'Integer'|'ByteArray'|'Array'|'Address';

interface AttachedAssets {
  [asset: 'NEO'|'GAS']: string;
}
// KEY: Asset symbol (only NEO or GAS)
// VALUE: Parsed amount to attach

interface AssetIntentOverrides {
  inputs: AssetInput[];
  outputs: AssetOutput[];
}

interface AssetInput {
  txid: string;
  index: number;
}

interface AssetOutput {
  asset: string;
  address: number;
  value: string;
}

</pre>


'''Success return value'''

interface InvokeOutput {
  txid: string; // The transaction ID of the invocation
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if transaction is broadcast by wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}


'''Error return value'''

<pre>
interface Error {
  type: string; // `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_INPUT`|`CANCELED`
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
invokeMulti({
  invokeArgs: [
    {
      scriptHash: '505663a29d83663a838eee091249abd167e928f5',
      operation: 'storeData',
      arguments: [
        {
          type: 'string',
          value: 'hello'
        }
      ],
      attachedAssets: {
        NEO: '100',
        GAS: '0.0001',
      },
      triggerContractVerification: true,
    },
    {
      scriptHash: '505663a29d83663a838eee091249abd167e928f5',
      operation: 'purchaseTicket',
      arguments: [
        {
          type: 'number',
          value: '10'
        }
      ],
    }
  ],
  fee: '0.001',
  network: 'TestNet',
  broadcastOverride: false,
  txHashAttributes: [
    {
      type: 'Boolean',
      value: true,
      txAttrUsage: 'Hash1'
    }
  ]
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Invoke transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hashes is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Batch invoke inputs into script, and handle assets to each invoke as outputs
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


====signMessage====
Signs a provided messaged with an account selected by user. A randomized salt prefix is added to the input string before it is signed, and it is encased in a non-executable transaction before signed. This ensures allow compatibility with Ledger devices.


'''Method Interface'''

<pre>
function signMessage({message: string}): Promise<SignedMessage>
</pre>


'''Input arguments'''

<pre>
interface SignMessageArgs {
  message: string; // Arbitrary message to sign
}
</pre>


'''Success return value'''

<pre>
interface SignedMessage {
  publicKey: string; // Public key of account that signed message
  message: string; // Original message signed
  salt: string; // Salt added to original message as prefix, before signing
  data; string; // Signed message
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
signMessage({
  message: 'Hello World!',
})
.then((signedMessage: SignedMessage) => {
  const {
    publicKey,
    message,
    salt,
    data,
  } = signedMessage;

  console.log('Public key used to sign:', publicKey);
  console.log('Original message:', message);
  console.log('Salt added to message:', salt);
  console.log('Signed data:', data);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case UNKNOWN_ERROR:
      console.log(description);
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Present the message to the user for signing
* Create a randomized salt value to be prefixed to the message before signing
* Create the hexstring to be signed. '010001f0' + {length of salt+message in hex} + salt + message + '0000'
* Sign the hexstring value once the user confirms
* Return to dapp

For more details, please see:
[https://docs.switcheo.network/#signing-messages-for-neo]

Example
<pre>
{
  publicKey: '0241392007396d6ef96159f047967c5a61f1af0871ecf9dc82afbedb68afbb949a',
  data: '0147fb89d0999e9d8a90edacfa26152fe695ec8b3770dcad522048297ab903822e12472364e254ff2e088fc3ebb641cc24722c563ff679bb1d1623d08bd5863d0d',
  salt: '058b9e03e7154e4db1e489c99256b7fa',
  message: 'Hello World!',
}
</pre>

====deploy====
Will deploy a compiled smart contract to the blockchain with the provided input parameters. The GAS cost for deploying the contract will be calculated by the provider, and displayed to the user upon tx acceptance or rejection.


'''Method Interface'''

<pre>
function deploy({
  name: string,
  version: string,
  author: string,
  email: string,
  description: string,
  needsStorage?: boolean,
  dynamicInvoke?: boolean,
  isPayable?: boolean,
  parameterList: string,
  returnType: string,
  code: string,
  network?: string,
  broadcastOverride?: boolean,
}): Promise<DeployOutput>
</pre>


'''Input arguments'''

<pre>
interface DeployArgs {
  name: string;
  version: string;
  author: string;
  email: string;
  description: string;
  needsStorage?: boolean;
  dynamicInvoke?: boolean;
  isPayable?: boolean;
  parameterList: string;
  returnType: string;
  code: string;
  network?: string - Network to submit this request to. If omitted, will default to network the wallet is currently set to.
  broadcastOverride?: boolean; // In the case that the dApp would like to be responsible for broadcasting the signed transaction rather than the wallet provider
}
</pre>


'''Success return value'''

<pre>
interface DeployOutput {
  txid: string;
  nodeUrl?: string; // The node which the transaction was broadcast to. Returned if transaction is broadcast by wallet provider
  signedTx?: string; // The serialized signed transaction. Only returned if the broadcastOverride input argument was set to True
}
</pre>


'''Error return value'''

<pre>
interface Error {
  type: string;
  description: string;
  data: string;
}
</pre>


'''Example'''

<pre>
deploy({
  name: 'Hello world!',
  version: 'v0.0.1',
  author: 'John Smith',
  email: 'info@o3.network',
  description: 'My first contract.',
  needsStorage: true,
  dynamicInvoke: false,
  isPayable: false,
  parameterList: '0710',
  returnType: '05',
  code: '53c56b0d57616b652075702c204e454f21680f4e656f2e52756e74696d652e4c6f6761006c7566',
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Deploy transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch(({type: string, description: string, data: any}) => {
  switch(type) {
    case UNKNOWN_ERROR:
      console.log(description);
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Run a testinvoke on the deploy transaction to get the gas cost in order to deploy the contract
* Display the deploy input parameters to the user along with the associated deployment fee
* Sign transaction upon receiving confirmation from user
* If the "broadcastOverride" input argument is set to True, return the serialized signed transaction to the dApp
* Else broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}
</pre>


===Events===

dApps can listen for events emitted by the wallet provider using the `addEventListener` method.

====addEventListener====

'''Method Interface'''

<pre>
function addEventListener(event: Event, callback: Function): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
  NETWORK_CHANGED = 'NETWORK_CHANGED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  BLOCK_HEIGHT_CHANGED = 'BLOCK_HEIGHT_CHANGED',
  TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED'
}
</pre>

=====READY=====

On a READY event, the callback will fire with a single argument with information about the wallet provider. At any time a READY event listener is added, it will immidiately be called if the provider is already in a ready state. This provides a single flow for dapp developers since this listener should start any and all interactions with the dapi protocol.
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
}
</pre>

=====ACCOUNT_CHANGED=====

On a ACCOUNT_CHANGED event, the callback will fire with a single argument of the new account. This occurs when an account is already connected to the dapp, and the user has changed the connected account from the dapi provider side.
<pre>
interface Account {
  address: string; // Address of the connected account
  label?: string; // A label the users has set to identify their wallet
}
</pre>

=====CONNECTED=====
On a CONNECTED event, the user has approved the connection of the dapp with one of their accounts. This will fire the first time any of one of the following methods are called from the dapp: getAccount, invoke, send.

<pre>
interface Account {
  address: string; // Address of the connected account
  label?: string; // A label the users has set to identify their wallet
}
</pre>


=====DISCONNECTED=====

On a DISCONNECTED event, the account connected to the dapp via the dapi provider has been disconnected (logged out).


=====NETWORK_CHANGED=====

On a NETWORK_CHANGED event, the callback will fire with a single argument of the new network details. This occurs when the user has changed the network on their provider wallet.

<pre>
interface Networks {
  networks: string[]; // Array of network names the wallet provider has available for the dapp developer to connect to.
  defaultNetwork: string; // Network the wallet is currently set to.
}
</pre>

Example:
<pre>
{
  networks: ["MainNet"],
  defaultNetwork: "MainNet",
}
</pre>

=====BLOCK_HEIGHT_CHANGED=====

On a BLOCK_HEIGHT_CHANGED event, the block has advanced to the next.

<pre>
interface BlockHeightChanged {
  network: string; // Network of the block which changed
  blockHeight: integer; // Height of the new block
  blockTime: integer; // Timestamp of the new block
  blockHash: string; // Hash of the new block
  tx: string[]; // List of transaction ids executed in the new block
}
</pre>

Example:
<pre>
{
  "blockHash": "0x5d19f31f5488ebcb0ab4aabfbead2118744b59e6c91b42696cee73f026e6dde8",
  "blockHeight": 2619937,
  "blockTime": 1557382020,
  "network": "TestNet",
  "tx": [
    "8f321fe22c4993d863e369fe30798c50a24400cec714373f63fcd88cb5402976"
  ]
}
</pre>

=====TRANSACTION_CONFIRMED=====

On a TRANSACTION_CONFIRMED event, a previously broadcast transaction via the dapi has been confirmed by the blockchain.

<pre>
interface BlockHeightChanged {
  txid: string; // Transaction id which was confirmed on chain
  blockHeight: integer; // Height of the new block
  blockTime: integer; // Timestamp of the new block
}
</pre>

Example:
<pre>
{
  "txid": "8f321fe22c4993d863e369fe30798c50a24400cec714373f63fcd88cb5402976",
  "blockHeight": 2619937,
  "blockTime": 1557382020
}
</pre>


====removeEventListener====

Removes any callback listeners previously set for a given event.

'''Method Interface'''

<pre>
function removeEventListener(event: Event): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
  NETWORK_CHANGED = 'NETWORK_CHANGED',
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  BLOCK_HEIGHT_CHANGED = 'BLOCK_HEIGHT_CHANGED',
  TRANSACTION_CONFIRMED = 'TRANSACTION_CONFIRMED'
}
</pre>

===Error handling===

All methods return a promise which will result in a resolve or reject. In the case of a rejection, the return argument will be an object formatted with standard fields for the type of error, a brief description, and any raw error data.

<pre>
interface Error {
  type: string;
  description?: string;
  data?: any;
}
</pre>

Common error definitions
<pre>
NO_PROVIDER -> Thrown when there is no interface capable of interacting with NEO blockchain
CONNECTION_DENIED -> Thrown when API provider refuses to execute a transaction (e.g. trying to execute a transaction on an unavialable network)
RPC_ERROR -> Thrown when a command relying on RPC connection to a network node fails
MALFORMED_INPUT -> Thrown when an input such as the address is not a valid NEO address
CANCELED -> Thrown when a user cancels, or refuses the dapps request
INSUFFICIENT_FUNDS -> Thrown when the action does not have a sufficient balance
</pre>


==Rational==

This protocol will allow dApp developers to create applications that interact with the NEO blockchain without having to be concerned about managing a full wallet within their application or the details related to handing transaction creation or broadcasting. This will also allow dApps to allow users to transact in a secure fashion that does not require sharing of their private key.

==Implementation==

JS implementation to demonstrate the usage of these methods from a dapp developer.

o3-dapi-neo - [https://github.com/O3Labs/o3-dapi/tree/master/packages/neo Github]
